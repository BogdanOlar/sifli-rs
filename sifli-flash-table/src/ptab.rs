/// ptab.json Parser

use serde::{Deserialize, Serialize};
use anyhow::Result;
use anyhow::anyhow;

// In the ftab.c currently generated by the SDK, 
// this macro is overwritten at the beginning of the file.
const FLASH_TABLE_START_ADDR: u32 = 0x1200_0000;

const FLASH_CAL_TABLE_SIZE: u32 = 8*1024;
// const FLASH_CAL_TABLE_START_ADDR: u32 = FLASH_TABLE_START_ADDR + FLASH_TABLE_SIZE;

const FLASH_BOOT_PATCH_CODE_START_ADDR: u32 = 0x1001_0000;
const FLASH_BOOT_PATCH_CODE_SIZE: u32 = 64*1024;
const FLASH_BOOT_PATCH_DATA_SIZE: u32 = 64*1024;

// primary bootloader data
const BOOTLOADER_RAM_DATA_START_ADDR: u32 = 0x2000_0000;

/// Represents the entire partition table structure
#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct PartitionTableItem {
    /// Memory type (e.g., "flash2", "psram1")
    pub(crate) mem: String,
    
    /// Base memory address
    pub(crate) base: String,
    
    /// Regions within this memory segment
    pub(crate) regions: Vec<Region>,
}

/// Represents a specific region within a memory segment
#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub(crate) struct Region {
    /// Offset from the base address
    pub(crate) offset: String,
    
    /// Maximum size of the region
    pub(crate) max_size: String,
    
    /// Tags describing the region's purpose
    #[serde(default)]
    pub(crate) tags: Option<Vec<String>>,
    
    /// Image name associated with the region
    #[serde(default)]
    pub(crate) img: Option<String>,
    
    /// Executable associated with the region
    #[serde(default)]
    pub(crate) exec: Option<String>,
    
    /// Optional flash table information
    #[serde(default)]
    pub(crate) ftab: Option<FlashTableInfo>,
}

/// Represents additional flash table information
#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
pub(crate) struct FlashTableInfo {
    /// Name of the flash table entry
    pub(crate) name: String,
    
    /// Addressing information
    pub(crate) address: Vec<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Info {
    pub base_addr: u32,
    pub xip_addr: u32,
    pub size: u32, 
}

impl Info {
    pub fn new(base_addr: u32, xip_addr: u32, size: u32) -> Self {
        Self { base_addr, xip_addr, size }
    }
}

impl Default for Info {
    fn default() -> Self {
        Self::new(u32::MAX, u32::MAX, u32::MAX)
    }
}

pub struct Ptab {
    pub partition_table: Vec<PartitionTableItem>,
    pub flash_table_info: Info,
    pub hcpu_code_info: Option<Info>,
    // pub lcpu_code_info: Option<Info>,
    pub flash_cal_info: Info,
    pub primary_bl_patch_info: Info,
    pub primary_bl_patch2_info: Info,
    pub secondary_bl_info: Info,
}

impl Ptab {
    pub fn new(contents: &String) -> Result<Self> {
        let partition_table: Vec<PartitionTableItem> = serde_hjson::from_str(contents)?;
        let mut hcpu_code_info: Option<Info> = None;
        let mut secondary_bl_info: Info = Default::default();

        let mut set_ftab_value = | ftab_addr_str: &str, ftab_name: &str, addr: u32, size: u32 | -> Result<()> {
            let info = match ftab_name {
                "bootloader" => &mut secondary_bl_info,
                "main" => { 
                    if hcpu_code_info == None {
                        hcpu_code_info = Some(Default::default());
                    }
                    &mut hcpu_code_info.as_mut().unwrap()
                },
                _ => Err(anyhow!("Unknown ftab name"))?,
            };
            info.size = size;
            
            Ok(match ftab_addr_str {
                "base" => {
                    info.base_addr = addr;
                },
                "xip" => {
                    info.xip_addr = addr;
                },
                _ => Err(anyhow!("Unknown address type"))?,
            })
        };

        partition_table.iter()
            .try_for_each::<_, Result<()>>(|ptab_item| {
                let ptab_item_base = hex_str_to_u32(&ptab_item.base)?;
                ptab_item.regions.iter()
                    .filter(|region| region.ftab.is_some())
                    .try_for_each::<_, Result<()>>(|region| {
                        let start_addr = ptab_item_base + hex_str_to_u32(&region.offset)?;
                        for ftab_addr in &region.ftab.as_ref().unwrap().address {
                            set_ftab_value(
                                ftab_addr.as_str(),
                                &region.ftab.as_ref().unwrap().name, 
                                start_addr,
                                hex_str_to_u32(&region.max_size)?,
                            )?;
                        }
                        Ok(())
                    })?;
                Ok(())
            })?;
        
        let (_flash_table_start_addr, flash_table_size) = find_by_tag(&partition_table, "FLASH_TABLE")?.unwrap();

        let flash_table_info = Info {
            // use FLASH_TABLE_START_ADDR instead of flash_table_start_addr
            // because this macro is overwritten at the beginning of auto-generated ftab.c.
            base_addr: FLASH_TABLE_START_ADDR,
            xip_addr: 0,
            size: flash_table_size,
        };

        let flash_cal_info = Info {
            base_addr: flash_table_info.base_addr + flash_table_info.size,
            xip_addr: 0,
            size: FLASH_CAL_TABLE_SIZE,
        };

        let (bl_patch_data_addr, bl_patch_data_size)  = 
            find_by_tag(&partition_table, "BOOTLOADER_RAM_DATA")?
            .unwrap_or((BOOTLOADER_RAM_DATA_START_ADDR, FLASH_BOOT_PATCH_DATA_SIZE));

        let primary_bl_patch_ram_addr = bl_patch_data_addr + bl_patch_data_size;
        
        // https://github.com/OpenSiFli/SiFli-SDK/issues/10
        let primary_bl_patch_info = Info {
            // base_addr: flash_cal_info.base_addr + flash_cal_info.size,
            base_addr: FLASH_BOOT_PATCH_CODE_START_ADDR,
            xip_addr: primary_bl_patch_ram_addr,
            size: FLASH_BOOT_PATCH_CODE_SIZE,
        };
        
        let primary_bl_patch2_info = Info {
            base_addr: primary_bl_patch_ram_addr,
            xip_addr: primary_bl_patch_ram_addr,
            size: FLASH_BOOT_PATCH_CODE_SIZE,
        };

        Ok(Self {
            partition_table,
            flash_table_info,
            hcpu_code_info,
            // lcpu_code_info,
            flash_cal_info,
            primary_bl_patch_info,
            primary_bl_patch2_info,
            secondary_bl_info,
        })
    }

}

/// return: (base_addr, size)
fn find_by_tag(table: &Vec<PartitionTableItem>, tag: &str) -> Result<Option<(u32, u32)>> {
    // Collect all matching regions across all partition tables
    let matching_regions = table
        .iter()
        .flat_map(|pt| {
            pt.regions
                .iter()
                .filter(|region| {
                    region.tags
                        .as_ref()
                        .map_or(false, |tags| tags.contains(&tag.to_string()))
                })
                .map(|region| {
                    // Convert hex strings to u32
                    let base = hex_str_to_u32(&pt.base)?;
                    let offset = hex_str_to_u32(&region.offset)?;
                    let size = hex_str_to_u32(&region.max_size)?;
                    
                    Ok((base + offset, size))
                })
                .collect::<Vec<_>>()
        })
        .collect::<Result<Vec<_>>>()?;

    // Handle different search result scenarios
    match matching_regions.len() {
        0 => Ok(None),
        1 => Ok(Some(matching_regions[0].clone())),
        _ => Err(anyhow!("Multiple regions found for tag: {}", tag)),
    }
}

fn hex_str_to_u32(str: &str) -> Result<u32> {
    u32::from_str_radix(&str[2..], 16).map_err(|err| err.into())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_ptab() {
        // Construct the path to the ptab.json file
        let mut path = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        path.push("test/em-lb525/ptab.json");
        let contents = std::fs::read_to_string(path).unwrap();
        // Parse the partition table
        let result = Ptab::new(&contents);
        
        // Assert that parsing was successful
        assert!(result.is_ok(), "Failed to parse partition table");
        
        let partition_table = result.unwrap();
        
        // Basic validation checks
        assert_eq!(partition_table.partition_table.len(), 4, "Expected 4 memory segments");
        
        // Check first memory segment (flash2)
        let flash2 = &partition_table.partition_table[0];
        assert_eq!(flash2.mem, "flash2");
        assert_eq!(flash2.base, "0x12000000");
        assert_eq!(flash2.regions.len(), 6, "Expected 6 regions in flash2");
        
        // Validate a specific region
        let first_region = &flash2.regions[0];
        assert_eq!(first_region.offset, "0x00000000");
        assert_eq!(first_region.max_size, "0x00008000");
        assert!(first_region.tags.as_ref().unwrap().contains(&"FLASH_TABLE".to_string()));
    }
}